---
title: "SFA2 - Death estimations"
author: "Cassandra Wattenburger"
date: "1/6/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(results = "show")
knitr::opts_chunk$set(message = FALSE)
```

```{r}
# Clear working directory, load in packages, generate package info
rm(list=ls())

library("tidyverse")
library("trelliscopejs")

sessionInfo()
```

# Import data

* The already prepped data from 03_SFA2_growthestimation.Rmd
* Taxonomy
* Metadata

```{r}
# Relational abundances, prepped
norm_prepped <- readRDS("../data_intermediate/SFA2_norm_prepped.rds")

# Taxonomy
tax <- readRDS("../data_intermediate/SFA2_taxonomy.rds")

# Metadata
meta <- readRDS("../data_intermediate/SFA2_metadata.rds")
```

# Estimate death

Create death parameter saving function:

```{r}
# Function: Saves chosen death estimate from below algorhithm
save_fit <- function(label, start, end, df_sub, output) {
  # Save estimate info
  est <- NULL; coeff <- NULL; yint <- NULL; residuals <- NULL; pval <- NULL; thisrow <- data.frame() # clear previous
  est <- lm(abund ~ time, data=df_sub[start:end,])
  coeff <- as.numeric(est$coefficients[2])
  yint <- as.numeric(est$coefficients[1])
  residuals <- sum(abs(resid(est)))
  pval <- summary(est)$coefficients[2,4]
  thisrow <- data.frame(label, start, end, coeff, yint, pval, residuals)
  output <- bind_rows(output, thisrow)
  return(output)
}
```

Estimate:

```{r}
## Requires a dataframe with columns containing a unique label for each data point, abundance values, time points
## df = data frame containing time series with abundance values (ln transformed), long format
## df must contain columns named:
### label = column with unique identifier for each time series
### abund = column with abundance values at each time point
### time = column with time point values
df <- norm_prepped
death_estimates <- data.frame()
for (label in as.character(unique(df$label))) {
    
  # Subset one time series using the label
  df_sub <- data.frame()
  df_sub <- df[df$label==label,] 
  stop <- FALSE
    
  # Sliding window
  for (start in 1:(nrow(df_sub) - 3)) {
    stop <- FALSE
    for (end in (start + 3):nrow(df_sub)) {
      if (stop == TRUE) {break}
     
      # Fit linear model to the window
      window_lm <- NULL; window_p <- NULL; window_coeff <- NULL
      window_lm <- lm(abund ~ time, data = df_sub[start:end,])
      window_p <- summary(window_lm)$coefficients[2,4]
      window_coeff <- window_lm$coefficients[2]
  
      # If a suitable fit is found and more time points exist that were not included, try extending the window
      if (window_p <= 0.05 & window_coeff < 0 & end < nrow(df_sub)) {
        for (extend_end in ((end+1):nrow(df_sub))) {
          if (stop == TRUE) {break}
            
          # Fit linear model to previous, non-extended window
          prevwindow_lm <- NULL; prevwindow_p <- NULL; prevwindow_coeff <- NULL 
          prevwindow_lm <- lm(abund ~ time, data = df_sub[start:(extend_end - 1),])
          prevwindow_p <- summary(prevwindow_lm)$coefficients[2,4]
          prevwindow_coeff <- prevwindow_lm$coefficients[2]
            
          # Fit linear model to the extended window
          newwindow_lm <- NULL; newwindow_p <- NULL; newwindow_coeff <- NULL 
          newwindow_lm <- lm(abund ~ time, data = df_sub[start:extend_end,])
          newwindow_p <- summary(newwindow_lm)$coefficients[2,4]
          newwindow_coeff <- newwindow_lm$coefficients[2]
            
          # If see improvement and can add more data, continue extending the window
          if (newwindow_p <= prevwindow_p & newwindow_coeff < 0 & extend_end < nrow(df_sub)) {
            next
          }
            
          # If no improvement, save the previous fit
          else if (newwindow_p > prevwindow_p & prevwindow_coeff < 0 & extend_end < nrow(df_sub)) {
            end <- extend_end - 1
            death_estimates <- save_fit(label, start, end, df_sub, death_estimates)
            stop <- TRUE
          }
            
          # If see improvement (or no harm) but no more data points to fit, save the extended fit
          else if (newwindow_p <= prevwindow_p & newwindow_coeff < 0 & extend_end == nrow(df_sub)) {
            end <- extend_end
            death_estimates <- save_fit(label, start, end, df_sub, death_estimates)
            stop <- TRUE
          } 
        }
      }
        
      # If no more data available to add to model, save the fit
      else if (window_p <= 0.05 & window_coeff < 0 & end == nrow(df_sub)) {
        death_estimates <- save_fit(label, start, end, df_sub, death_estimates)
        stop <- TRUE
      }
    }
  }
}

dim(death_estimates)
```

### Remove "essentially perfect fits"

I can't find any guidance on how to determine whether or not a fit is "perfect" but I know that the residuals are essentially equal to 0 for perfect fits. I'll use 0.0001 as a filtering threshold for removal.

```{r}
# Remove "perfect" fits as precaution
death_estimates <- filter(death_estimates, residuals >= 0.0001)

dim(death_estimates)
```

### Select best fit for each time series

* Lowest p-value of the slope

```{r}
# Choose lowest p-value window
lowest_pvals <- death_estimates %>% 
  group_by(label) %>% 
  summarize(pval = min(pval)) %>% 
  ungroup()

dim(lowest_pvals)

# Filter chosen estimates
death_estimates <- death_estimates %>% 
  semi_join(lowest_pvals)

dim(death_estimates)
```

# False positive control

Histogram of quality filtered p-values from actual estimates:

```{r}
hist(death_estimates$pval, xlab="P-values", main="Histogram of quality filtered p-values")
```

This p-value distribution is anti-conservative based on the trailing right tail (this is a good thing). However, it appears that there must be some proportion of false positives based on how high that right tail is compared to the initial spike at the beginning of the distribution. We must do some form of multiple comparison control.

See: http://varianceexplained.org/statistics/interpreting-pvalue-histogram/

I'm choosing to use a permutation approach where I use my death estimating algorhithm on randomly generated data with characteristics of the real data. I'll use this false positive information to filter my real estimates. Traditional false positive control methods are far too conservative for my dataset.

### Simulate random data

Completely random data designed to reflect actual data, if we detect "significant" death rate estimates from this, we must control for that, because the same thing can happen in our actual data.

Information about real dataset to use for simulating random data:

* number of time points
* min and max of abundance

```{r, results="show"}
# Minimum and maximum relational abundances
min_abund <- min(norm_prepped$abund)
max_abund <- max(norm_prepped$abund)
avg_abund <- mean(norm_prepped$abund)
sd_abund <- sd(norm_prepped$abund)

hist(norm_prepped$abund)

# Number of time points
num_tps <- norm_prepped %>% 
  group_by(label) %>% 
  summarize(num_points = n()) %>% 
  ungroup()

min_pts <- min(num_tps$num_points)
max_pts <- max(num_tps$num_points)
avg_pts <- mean(num_tps$num_points)
sd_pts <- sd(num_tps$num_points)

hist(num_tps$num_points)
```

Import previously generated simulated time series, see 03_SFA2_deathestimation.Rmd

```{r}
sim_data <- readRDS("../data_intermediate/SFA2_simulated.rds")
```

### Estimate "death" on simulated data

Same method. I really need to turn this into a function.

```{r}
# Prep simulated data (rename columns)
sim_prepped <- sim_data %>% 
  select(label=simulation, abund=rand_abund, time=rand_day)

# Run algorithinmmmnmnm
df <- sim_prepped
sim_estimates <- data.frame()
for (label in as.character(unique(df$label))) {
    
  # Subset one time series using the label
  df_sub <- data.frame()
  df_sub <- df[df$label==label,] 
  stop <- FALSE
    
  # Sliding window
  for (start in 1:(nrow(df_sub) - 3)) {
    stop <- FALSE
    for (end in (start + 3):nrow(df_sub)) {
      if (stop == TRUE) {break}
     
      # Fit linear model to the window
      window_lm <- NULL; window_p <- NULL; window_coeff <- NULL
      window_lm <- lm(abund ~ time, data = df_sub[start:end,])
      window_p <- summary(window_lm)$coefficients[2,4]
      window_coeff <- window_lm$coefficients[2]
  
      # If a suitable fit is found and more time points exist that were not included, try extending the window
      if (window_p <= 0.05 & window_coeff < 0 & end < nrow(df_sub)) {
        for (extend_end in ((end+1):nrow(df_sub))) {
          if (stop == TRUE) {break}
            
          # Fit linear model to previous, non-extended window
          prevwindow_lm <- NULL; prevwindow_p <- NULL; prevwindow_coeff <- NULL 
          prevwindow_lm <- lm(abund ~ time, data = df_sub[start:(extend_end - 1),])
          prevwindow_p <- summary(prevwindow_lm)$coefficients[2,4]
          prevwindow_coeff <- prevwindow_lm$coefficients[2]
            
          # Fit linear model to the extended window
          newwindow_lm <- NULL; newwindow_p <- NULL; newwindow_coeff <- NULL 
          newwindow_lm <- lm(abund ~ time, data = df_sub[start:extend_end,])
          newwindow_p <- summary(newwindow_lm)$coefficients[2,4]
          newwindow_coeff <- newwindow_lm$coefficients[2]
            
          # If see improvement and can add more data, continue extending the window
          if (newwindow_p <= prevwindow_p & newwindow_coeff < 0 & extend_end < nrow(df_sub)) {
            next
          }
            
          # If no improvement, save the previous fit
          else if (newwindow_p > prevwindow_p & prevwindow_coeff < 0 & extend_end < nrow(df_sub)) {
            end <- extend_end - 1
            sim_estimates <- save_fit(label, start, end, df_sub, sim_estimates)
            stop <- TRUE
          }
            
          # If see improvement (or no harm) but no more data points to fit, save the extended fit
          else if (newwindow_p <= prevwindow_p & newwindow_coeff < 0 & extend_end == nrow(df_sub)) {
            end <- extend_end
            sim_estimates <- save_fit(label, start, end, df_sub, sim_estimates)
            stop <- TRUE
          } 
        }
      }
        
      # If no more data available to add to model, save the fit
      else if (window_p <= 0.05 & window_coeff < 0 & end == nrow(df_sub)) {
        sim_estimates <- save_fit(label, start, end, df_sub, sim_estimates)
        stop <- TRUE
      }
    }
  }
}
dim(sim_estimates)
```

### Remove "essentially perfect fits"

I can't find any guidance on how to determine whether or not a fit is "perfect" but I know that the residuals are essentially equal to 0 for perfect fits. I'll use 0.0001 as a filtering threshold for removal.

```{r}
# Remove "perfect" fits as precaution
sim_estimates <- filter(sim_estimates, residuals >= 0.0001)

dim(sim_estimates)
```

### Select best fit for each time series

* Lowest p-value of the slope

```{r}
# Choose lowest p-value window
sim_lowest_pvals <- sim_estimates %>% 
  group_by(label) %>% 
  summarize(pval = min(pval)) %>% 
  ungroup()

dim(sim_lowest_pvals)

# Filter chosen estimates
sim_estimates <- sim_estimates %>% 
  semi_join(sim_lowest_pvals)

dim(sim_estimates)
```

False positive rates:

```{r}
# False positives
a <- nrow(sim_estimates[sim_estimates$pval <= 0.05,])
b <- nrow(sim_estimates[sim_estimates$pval <= 0.025,])
c <- nrow(sim_estimates[sim_estimates$pval <= 0.01,])
d <- nrow(sim_estimates[sim_estimates$pval <= 0.005,])
e <- nrow(sim_estimates[sim_estimates$pval <= 0.001,])
f <- nrow(sim_estimates[sim_estimates$pval <= 0.0005,])

false_pos <- data.frame(c(0.05, 0.025, 0.01, 0.005, 0.001, 0.0005), c(a,b,c,d,e,f))
colnames(false_pos)=c("pvalue","false")

ggplot(false_pos, aes(x=pvalue, y=false)) +
  geom_point() +
  geom_smooth(method="lm", linetype=2) +
  labs(title="Relationship between p-value and number of false positives", x="P-value", y="False positives") +
  theme_test()
  
```

Find 10%, 5%, 2.5%, 1% false positive allowance p-value thresholds

* Using linear model to predict

```{r}
falsepos_lm <- lm(false ~ pvalue, data=false_pos)
falsepos_lm
```

```{r}
# Extract model coefficients
slope <- as.numeric(falsepos_lm$coefficients[2])
intercept <- as.numeric(falsepos_lm$coefficients[1])

# 10% false positive allowance
false10_pval <- (100 - intercept)/slope

## 5% false positive allowance
false5_pval <- (50 - intercept)/slope

# 2.5% false positive allowance
false2.5_pval <- (25 - intercept)/slope

# 1% false positive allowance
false1_pval <- (10 - intercept)/slope
```

### Filter by false positive rate

Number of estimates in each category:

```{r, restuls="show"}
# ~10% false positives
death_falsepos10 <- subset(death_estimates, pval <= false10_pval)
nrow(death_falsepos10)

# ~5% false positives
death_falsepos5 <- subset(death_estimates, pval <= false5_pval)
nrow(death_falsepos5)

# 2.5%
death_falsepos2.5 <- subset(death_estimates, pval <= false2.5_pval)
nrow(death_falsepos2.5)

# 1%
death_falsepos1 <- subset(death_estimates, pval <= false1_pval)
nrow(death_falsepos1)
```

# Choose FPR

10% false positive rate:

```{r}
set.seed(10)

# 10% false positive rate
labels10 <- as.character(death_falsepos10$label)

# Randomly plot 10 w/death estimate
for (n in 1:10) {
  # Choose randomly
  rand_num <- sample(1:nrow(death_falsepos10), 1)
  l <- labels10[rand_num]
  
  # Estimated death window
  start <- death_falsepos10 %>% 
    filter(label==l) %>% 
    .$start
  
  end <- death_falsepos10 %>% 
    filter(label==l) %>% 
    .$end
  
  # Plot
  data_sub <- norm_prepped %>% 
    filter(label == l)
  plot <- data_sub %>% 
    ggplot(aes(x=time, y=abund)) +
    geom_smooth(method="lm", data=data_sub[start:end,], linetype=2) +
    geom_point() +
    geom_line() +
    theme_test()
  print(plot)
}
    
```

5% false positive rate:

```{r}
set.seed(5)

# 10% false positive rate
labels5 <- as.character(death_falsepos5$label)

# Randomly plot 10 w/death estimate
for (n in 1:10) {
  # Choose randomly
  rand_num <- sample(1:nrow(death_falsepos5), 1)
  l <- labels5[rand_num]
  
  # Estimated death window
  start <- death_falsepos5 %>% 
    filter(label==l) %>% 
    .$start
  
  end <- death_falsepos10 %>% 
    filter(label==l) %>% 
    .$end
  
  # Plot
  data_sub <- norm_prepped %>% 
    filter(label == l)
  plot <- data_sub %>% 
    ggplot(aes(x=time, y=abund)) +
    geom_smooth(method="lm", data=data_sub[start:end,], linetype=2) +
    geom_point() +
    geom_line() +
    theme_test()
  print(plot)
}
    
```

Look similarly trustworthy. I'll go with 10% false positive rate because it retains more estimates.

# Calculate death metrics

### Calculate specific death rate (k)

Calculating the same as growth rate, but assuming loss instead of gain.

Steps:

* Use estimated slope from death curves to simulate death over a time interval
* Use simulated abundances to solve for k

Using estimates filtered at 10% false positives.

Formula: k=(log10(b)-log10(B))*2.303/t

Where k is specific death rate, B is abundance at beginning, b is abundance at end, and t is the time interval.

I found this guide helpful: http://miller-lab.net/MillerLab/protocols/general-bacteriology/calculating-growth-rate/

```{r}
# Generate abundances over time interval based on estimated slope
death_estimates2 <- data.frame()
B <- 1 # Start with one bacteria
for (l in death_falsepos10$label) {
  death_label <- filter(death_falsepos10, label==l)
  b <- (abs(death_label$coeff)*3)+1 # abundance three days later
  k <- (log10(b)-log10(B))*(2.303/3) # calculate k
  this_row <- cbind(death_label, k)
  death_estimates2 <- rbind(death_estimates2, this_row)
}
```

### Start and end day, change in abundance

```{r}
# Convert start and end to actual day
death_final <- data.frame()
for (l in as.character(unique(death_estimates2$label))) {
  # Isolate timeseries
  norm_label <- norm_prepped %>% 
    filter(label==l) %>% 
    arrange(time)
  death_label <- filter(death_estimates2, label==l)
  start <- death_label$start
  end <- death_label$end
  # Start and end day of death
  start_day <- norm_label[start,]$time
  end_day <- norm_label[end,]$time
  # Starting and ending relational abundance
  start_abund <- norm_label[start,]$norm_abund_avg
  end_abund <- norm_label[end,]$norm_abund_avg
  change_abund <- end_abund - start_abund
  # Save output
  this_row <- bind_cols(label = as.character(death_label$label), 
                        slope = death_label$coeff, yint = death_label$yint, k = death_label$k,
                        start_pt = death_label$start, end_pt = death_label$end,
                        start_day = start_day, end_day = end_day, 
                        start_abund = start_abund, end_abund = end_abund, change_abund = change_abund)
  death_final <- bind_rows(death_final, this_row)
}
```

## Half times

Formula: h = ln2/k

Where h is halving time and k is specific death rate (per day).

```{r}
# Calculate doubling time based on k
h.df <- data.frame()
for (l in as.character(unique(death_final$label))) {
        data_sub <- filter(death_final, label==l)
        k <- data_sub$k
        h <- log(2)/k
        thisrow <- cbind(data_sub, h)
        h.df <- rbind(h.df, thisrow)
}
h.df

mean(h.df$h)
sd(h.df$h)
min(h.df$h)
max(h.df$h)
```

# Tidy up and save data

Relational abundances:

```{r}
# Labels of estimated taxa
est_labels <- as.character(death_estimates$label)

# Extract from relational abundance table and clean up
norm_tidy <- norm_prepped %>% 
  filter(label %in% est_labels) %>% 
  select(label, everything(), norm_abund_avg, ln_norm_abund_avg=abund, Day=time) %>% 
  select(label, Inoculant, ASV, Day, norm_abund_avg, ln_norm_abund_avg)
```

```{r, eval=FALSE}
saveRDS(norm_tidy, file="../data_intermediate/SFA2_norm_deestimated2.rds")
```

Death estimates:

```{r}
# Add back metadata
death_tidy <- death_final %>% 
  mutate(Inoculant = gsub("([0-9]+)_.+", "\\1", label),
         ASV = gsub("[0-9]+_(.+)", "\\1", label)) %>% 
  select(label, Inoculant, ASV, slope:change_abund)
```

```{r, eval=FALSE}
saveRDS(death_tidy, file="../data_intermediate/SFA2_death_estimates2.rds")
```

# Number of estimates per inoculant

```{r}
death_tidy %>% 
  group_by(Inoculant) %>% 
  summarize(total = n()) %>% 
  ungroup()
```

# Create list of ASVs for PAPRICA

```{r, eval=FALSE}
death_asvs <- select(death_tidy, ASV)
write_tsv(death_asvs, file="../paprica_analysis/death_asvs2.txt")
```

# Summary of death

Number of estimates per inoculant:

```{r}
# Number of ASVs with estimates
length(unique(death_tidy$ASV))

# Estimates per inoculant
death_summary <- death_tidy %>% 
  group_by(Inoculant) %>% 
  summarize(num = n())

death_summary %>% 
  group_by() %>% 
  summarize(num_avg = mean(num), num_sd=sd(num))

# Min, max and mean k

```

# Plot death estimates

```{r}
# For messing with graphs
death_testing <- head(death_tidy)

count <- 0

for (l in as.character(death_tidy$label)) {
  count <- count + 1
  # Subset time series
  death_label <- filter(death_tidy, label==l)
  norm_label <- filter(norm_tidy, label==l) %>% 
  arrange(Day)
  # Title information
  asv <- death_label$ASV
  tax_info <- filter(tax, ASV == asv)
  
  title <- paste0(count, ". ", tax_info$Phylum, ", ", tax_info$Genus)
  # Graph with estimate
  graph <- ggplot(norm_label, aes(x=Day, y=ln_norm_abund_avg)) +
    geom_point(shape=1, size=3, color="#6F7378") +
    geom_line(color="#6F7378") +
    geom_smooth(method="lm", data=norm_label[death_label$start_pt:death_label$end_pt,], linetype=2, color="black") +
    labs(title=title, x="Day", y="ln Relational abundance") +
    theme_test() +
    theme(title = element_text(size=18),
        axis.title = element_text(size=16),
        axis.text = element_text(size=14))
  
  # Print
  print(graph)
  }
```

```{r, eval=FALSE, echo=FALSE}
# Plotting for presentations/posters
example_est <- death_tidy[129,]
example_dat <- filter(norm_tidy, label==example_est$label) %>% 
  mutate(startend = if_else(Day==example_est$start_day | Day==example_est$end_day, "yes", "no"))
example_tax <- filter(tax, ASV == example_est$ASV)
example_title <- paste0(example_tax$Phylum, ", ", example_tax$Genus)
  
example_plot <- ggplot(example_dat, aes(x=Day, y=ln_norm_abund_avg)) +
    geom_point(aes(shape=startend), size=4, color="#6F7378") +
    geom_line(color="#6F7378") +
    geom_smooth(method="lm", data=example_dat[example_est$start_pt:example_est$end_pt,],
                linetype=2, color="black") +
    labs(title=example_title, x="", y="") +
    scale_shape_manual(values=c(1, 16)) +
    theme_test() +
    theme(title = element_text(size=18),
        axis.text = element_text(size=16),
        legend.position = "none")

example_plot

ggsave("../figures/ISME18_deathexample.png", example_plot, width=5.3, height=3, units="in")
```

```{r, eval=FALSE, echo=FALSE}
# Plotting for presentations/posters
example_est <- death_tidy[157,]
example_dat <- filter(norm_tidy, label==example_est$label) %>% 
  mutate(startend = if_else(Day==example_est$start_day | Day==example_est$end_day, "yes", "no"))
example_tax <- filter(tax, ASV == example_est$ASV)
example_title <- paste0(example_tax$Phylum, ", ", example_tax$Genus)
  
bin1_plot <- ggplot(example_dat, aes(x=Day, y=ln_norm_abund_avg)) +
    geom_point(aes(shape=startend), size=4, color="#6F7378") +
    geom_line(color="#6F7378") +
    geom_smooth(method="lm", data=example_dat[example_est$start_pt:example_est$end_pt,],
                linetype=2, color="black") +
  geom_vline(xintercept = 9, linetype=2) +
    labs(title=example_title, x="", y="") +
    scale_shape_manual(values=c(1, 16)) +
    theme_test() +
    theme(title = element_text(size=18),
        axis.text = element_text(size=16),
        legend.position = "none")

bin1_plot

ggsave("../figures/ISME18_bin1example.png", bin1_plot, width=7.5, height=5, units="in")

example_est <- death_tidy[79,]
example_dat <- filter(norm_tidy, label==example_est$label) %>% 
  mutate(startend = if_else(Day==example_est$start_day | Day==example_est$end_day, "yes", "no"))
example_tax <- filter(tax, ASV == example_est$ASV)
example_title <- paste0(example_tax$Phylum, ", ", example_tax$Genus)
  
bin2_plot <- ggplot(example_dat, aes(x=Day, y=ln_norm_abund_avg)) +
    geom_point(aes(shape=startend), size=4, color="#6F7378") +
    geom_line(color="#6F7378") +
    geom_smooth(method="lm", data=example_dat[example_est$start_pt:example_est$end_pt,],
                linetype=2, color="black") +
  geom_vline(xintercept = 9, linetype=2) +
    labs(title=example_title, x="", y="") +
    scale_shape_manual(values=c(1, 16)) +
    theme_test() +
    theme(title = element_text(size=18),
        axis.text = element_text(size=16),
        legend.position = "none")

bin2_plot

ggsave("../figures/ISME18_bin2example.png", bin2_plot, width=7.5, height=5, units="in")

example_est <- death_tidy[162,]
example_dat <- filter(norm_tidy, label==example_est$label) %>% 
  mutate(startend = if_else(Day==example_est$start_day | Day==example_est$end_day, "yes", "no"))
example_tax <- filter(tax, ASV == example_est$ASV)
example_title <- paste0(example_tax$Phylum, ", ", example_tax$Genus)
  
bin3_plot <- ggplot(example_dat, aes(x=Day, y=ln_norm_abund_avg)) +
    geom_point(aes(shape=startend), size=4, color="#6F7378") +
    geom_line(color="#6F7378") +
    geom_smooth(method="lm", data=example_dat[example_est$start_pt:example_est$end_pt,],
                linetype=2, color="black") +
  geom_vline(xintercept = 9, linetype=2) +
    labs(title=example_title, x="", y="") +
    scale_shape_manual(values=c(1, 16)) +
    theme_test() +
    theme(title = element_text(size=18),
        axis.text = element_text(size=16),
        legend.position = "none")

bin3_plot

ggsave("../figures/ISME18_bin3example.png", bin3_plot, width=7.5, height=5, units="in")
```

